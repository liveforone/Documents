# Rust Book

- [Rust Book](#rust-book)
  - [update \& uninstall command](#update--uninstall-command)
  - [cargo command](#cargo-command)
  - [basic](#basic)
    - [변수 \& 가변/불변](#변수--가변불변)
    - [상수](#상수)
    - [숫자타입](#숫자타입)
    - [튜플](#튜플)
    - [배열](#배열)
    - [함수](#함수)
  - [소유권](#소유권)
    - [복사](#복사)
    - [참조](#참조)
    - [변경 가능한 참조](#변경-가능한-참조)
    - [슬라이스](#슬라이스)

## update & uninstall command

- `rustup update`
- `rustup self uninstall`

## cargo command

- `cargo new projectName`
- `cargo build`
- `cargo check` : build보다 가볍게 컴파일하여 오류를 체크함
- `cargo run`
- `cargo build --release` : 최적화하여 빌드(배포시)

## basic

### 변수 & 가변/불변

- 변수는 기본적으로 불변(immutable)이다.
- 가변 변수를 원하면 `mut` 키워드를 붙여야한다.
- `let x = 10` / `let mut x = 10`

### 상수

- `const`키워드로 정의하며 항상 불변상태를 가진다.
- 상수의 생명주기는 프로그램 종료까지이다.

### 숫자타입

- `i8` / `u8` / `i16`/ `u16` / `i32` / `u32` / `i64` / `u64` / `i128` / `isize` / `usize`
- isize와 usize는 컴퓨터의 아키텍처에 따라 사이즈가 달라진다.
- `f32` / `f64`

### 튜플

- `(값, 값, 값)`
- 튜플은 서로 다른 타입을 넣을 수 있다.
- 튜플은 인덱스로 접근하며 `변수명.인덱스`와 같은 형태로 접근한다.
- ex : `tup.0`

### 배열

- `[값, 값, 값]`
- 배열은 서로 같은 타입을 넣을 수 있다.
- 배열은 벡터에 비해 유연하지 않다. 고정 길이 형태를 가지기 때문이다.
- 배열은 인덱스로 접근한다. ex : `a[0]`
- 배열의 타입 선언은 `[타입; 갯수]`와 같은 형태로 선언한다.
- ex : `let list: [i32; 3] = [1, 2, 3]`

### 함수

- `fn`키워드로 선언한다.
- 함수는 snake case가 기본적인 컨벤션이다.
- 반환 값이 있는 경우 `-> 타입`으로 표현한다.
- `fn plus_one(x: i32) -> i32 {x + 1}`
- 여타 함수형 언어처럼 반환값이 있는 함수의 경우 함수 블록의 마지막 값이 리턴값이다.

## 소유권

### 복사

- 러스트는 `let s2 = s1`과 같은 대입을 하였을때, s1이 래퍼런스타입(일례로 String)이라면 힙 주소를 복사한다.
- 간단히 말해 래퍼런스타입을 대입하면 포인터 주소를 복사한다.
- 두 값은 같은 포인터 주소를 가르킨다.
- 이러한 이유로 복사가 일어나고 s1의 라이프타임이 끝나 메모리가 해제되면 복사한 s2도 문제가 발생할 수 있다.
- 이러한 이유로 메모리 안전을 위해 복사하였다면 복사한 값을 러스트는 더이상 유효하지 않다고 판단한다.

```rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world", s1);
//무효화된 참조를 했기에 에러가 발생한다.
```

- 얕은 복사와는 개념이 조금다르다. 러스트에서는 그냥 s1에서 s2로 옮겨지는 것(move)이기 때문이다.
- 결론적으로 러스트는 래퍼런스 타입 값을 어떤 값에 대입하면 기존 값을 무효화 해버리고 포인터 참조를 새롭게 대입된 값에 할당한다.
- 진짜 복사를 원한다면 `clone()`함수를 사용해야한다.

### 참조

- 러스트의 복사 방식 때문에 매개변수로 래퍼런스 타입을 던지는 것이 불안할 수도 있다.
- 왜냐면 소유권이 계속 이동하는 복잡한 상황에 놓이기 때문이다.
- 따라서 c++의 래퍼런스처럼 `&`를 통해서 참조자를 던질 수 있다.
- 참조자를 사용하면 소유권을 가져오지 않고 참조할 수 있다.
- 당연하게도 소유권을 가져온 것이 아니기에 수정과 같은 일은 불가능하다

```rust
let s1 = String::from("hello");
let len = calculate_length(&s1);
fn calculate_length(s: &String) -> usize {
    s.len()
}
```

### 변경 가능한 참조

- 변경이 가능한 참조도 존재한다.
- `&mut` 키워드를 사용하면된다.
- 다만 한 값에 대한 변경가능한 참조를 갖는 것(할당)은 한번이다.

```rust
let mut s = String::from("hello");
let r1 = &mut s;  //한 번의 참조할당은 가능하다.
let r2 = &mut s;  //error, 불가능하다.
```

- 다만 아래처럼 새로운 스코프를 연다면 가능하다.

```rust
let mut s = String::from("hello");
{
    let r1 = &mut s;
}
let r2 = &mut s;
```

### 슬라이스

- 문자열을 자르는 슬라이스는 러스트에서 이미 구현이 되어있다
- 슬라이스 타입은 `&str`이다.
- `&변수명[0..4]`와 같이 사용한다.
- 당연하게도 0인덱스부터 3까지를 가져온다.
- 앞/뒤를 생략할 수 있다. ex : `&s[..2]` / `&s[3..]`
