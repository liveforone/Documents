# Elixir Book

## Basic type

- integer, float(64bit), boolean, atom / symbol, string, list, tuple, nil
- binary, octal, hexadecimal 을 지원한다.
- 기본적으로 값들은 불변이다.

### 산술 연산

- 대부분의 연산은 다른 언어와 같다.
- 나눗셈을 할경우 float으로 리턴된다.
- 그러나 이를 원치 않을경우 `div()`나 `rem`함수를 사용하면된다.
- `round()`함수로 반올림을, `trunc()`함수로 반내림을 사용할 수 있다.

### 논리 연산

- `and`, `or`, `not`, `&&`, `||`, `!`, `===`, `!==`

### atoms

- 자신의 이름을 값으로 가지는 상수다. enum과 유사하다.
- `:이름` 과 같이 표현한다.
- true와 false도 사실 atom이다.

### 문자열 합치기

- `<>`를 사용하면 문자열을 합칠 수 있다.
- `"this" <> "is" <> "apple"`

### 문자열 보간

- `#{}`를 사용하여 문자열 보간을 한다.
- `"this is #{value}"`

## list and tuples

- 리스트는 다양한 타입으로 구성할 수 있다.
- 튜플 또한 다양한 타입으로 구성할 수 있다.
- list : []
- tuple : {}

### 리스트 합치기/빼기

- `++`, `--` 연산자를 활용하여 리스트를 합치고 뺄 수 있다.
- `[1, 2, 3] ++ [a, 1, "hi"]`
- 당연하게도 기존의 리스트를 수정하진 않고 새 리스트를 반환한다.
- 이는 엘릭서가 데이터 타입을 불변하게 유지하기 때문이다.

### head, tail

- `hd`는 리스트의 맨 첫번째 값을
- `tl`은 첫번째 값을 제외한 나머지 값들을 가져온다.
- 그러나 empty list일 경우 위의 함수 사용시 에러가 발생한다.

### 튜플의 원리

- 튜플은 값들을 메모리에 연속적으로 저장한다. 따라서 인덱스로 값들에 접근하거나 튜플의 사이즈(tuple_size() 함수 사용)를 얻는 속도는 빠르다.
- 인덱스는 0부터 시작한다.
- 튜플도 리스트와 마찬가지로 불변이다. 수정이 필요할 경우 새 튜플이 반환된다.
- `put_elem(튜플, 인덱스, 값)`함수로 값을 추가할 수 있다.

### 리스트 vs 튜플

- 리스트에서 원하는 값을 찾을 경우 리스트를 다 뒤져야하는 문제가 있다.
- 그러나 튜플은 그렇지 않다. 하지만 튜플을 만들거나 업데이트 하는 행위는 메모리에 access해야하기 때문에 비싸다.
- 길이가 길 경우 리스트를, 작으면서 고정될 경우 튜플을 쓰는 것이 바람직하다.
