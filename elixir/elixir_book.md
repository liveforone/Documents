# Elixir Book

- [Elixir Book](#elixir-book)
  - [Basic type](#basic-type)
    - [산술 연산](#산술-연산)
    - [논리 연산](#논리-연산)
    - [atoms](#atoms)
    - [문자열 합치기](#문자열-합치기)
    - [문자열 보간](#문자열-보간)
  - [list and tuples](#list-and-tuples)
    - [리스트 합치기/빼기](#리스트-합치기빼기)
    - [head, tail](#head-tail)
    - [튜플의 원리](#튜플의-원리)
    - [리스트 vs 튜플](#리스트-vs-튜플)
  - [패턴매칭](#패턴매칭)
    - [pattern operator](#pattern-operator)
    - [튜플 패턴매칭](#튜플-패턴매칭)
    - [리스트 패턴매칭](#리스트-패턴매칭)
    - [핀 연산자](#핀-연산자)

## Basic type

- integer, float(64bit), boolean, atom / symbol, string, list, tuple, nil
- binary, octal, hexadecimal 을 지원한다.
- 기본적으로 값들은 불변이다.

### 산술 연산

- 대부분의 연산은 다른 언어와 같다.
- 나눗셈을 할경우 float으로 리턴된다.
- 그러나 이를 원치 않을경우 `div()`나 `rem`함수를 사용하면된다.
- `round()`함수로 반올림을, `trunc()`함수로 반내림을 사용할 수 있다.

### 논리 연산

- `and`, `or`, `not`, `&&`, `||`, `!`, `===`, `!==`

### atoms

- 자신의 이름을 값으로 가지는 상수다. enum과 유사하다.
- `:이름` 과 같이 표현한다.
- true와 false도 사실 atom이다.

### 문자열 합치기

- `<>`를 사용하면 문자열을 합칠 수 있다.
- `"this" <> "is" <> "apple"`

### 문자열 보간

- `#{}`를 사용하여 문자열 보간을 한다.
- `"this is #{value}"`

## list and tuples

- 리스트는 다양한 타입으로 구성할 수 있다.
- 튜플 또한 다양한 타입으로 구성할 수 있다.
- list : []
- tuple : {}

### 리스트 합치기/빼기

- `++`, `--` 연산자를 활용하여 리스트를 합치고 뺄 수 있다.
- `[1, 2, 3] ++ [a, 1, "hi"]`
- 당연하게도 기존의 리스트를 수정하진 않고 새 리스트를 반환한다.
- 이는 엘릭서가 데이터 타입을 불변하게 유지하기 때문이다.

### head, tail

- `hd`는 리스트의 맨 첫번째 값을
- `tl`은 첫번째 값을 제외한 나머지 값들을 가져온다.
- 그러나 empty list일 경우 위의 함수 사용시 에러가 발생한다.

### 튜플의 원리

- 튜플은 값들을 메모리에 연속적으로 저장한다. 따라서 인덱스로 값들에 접근하거나 튜플의 사이즈(tuple_size() 함수 사용)를 얻는 속도는 빠르다.
- 인덱스는 0부터 시작한다.
- 튜플도 리스트와 마찬가지로 불변이다. 수정이 필요할 경우 새 튜플이 반환된다.
- `put_elem(튜플, 인덱스, 값)`함수로 값을 추가할 수 있다.

### 리스트 vs 튜플

- 리스트에서 원하는 값을 찾을 경우 리스트를 다 뒤져야하는 문제가 있다.
- 그러나 튜플은 그렇지 않다. 하지만 튜플을 만들거나 업데이트 하는 행위는 메모리에 access해야하기 때문에 비싸다.
- 길이가 길 경우 리스트를, 작으면서 고정될 경우 튜플을 쓰는 것이 바람직하다.

## 패턴매칭

- 기존의 switch문과 유사한 패턴매칭을 생각해선 안된다.
- 엘릭서의 패턴매칭은 값들과 값들을 매치시킨다고 보면 편하다.

### pattern operator

- pattern operator는 `=`연산자이다.
- 따라서 다음과 같은 식이 가능하다.
- `x = 1`, `1 = x`
- 만약 `2 = x`라고 한다면 `matchError`가 발생할 것이다.
- 패턴 매칭은 이러한 simple ex에만 사용되지 않는다.

### 튜플 패턴매칭

- `{a, b, c} = {:one, "two", 3}` 와 같은 패턴매칭이 가능하다.
- 여기서 `a`를 찍어보면 `:one`이 출력된다.
- 만약 사이즈가 다른 튜플을 매칭시키면 에러가 발생할 것이다.
- 또한 다른 타입을 삽입해도 그렇다. 왼쪽에 튜플을, 오른쪽에 리스트를 넣는다면 `matchError`가 발생한다.

### 리스트 패턴매칭

- `[a, b, c] = [:one, "two", 3]`
- 리스트 패턴매칭은 튜플과 사실상 동일하다.
- `[head | tail] = [1, 2, 3]`처럼 튜플과 달리 `|` 문법을 통해 head와 tail을 분류할 수 있고, 다른 크기를 매칭해도 문제없다.
- 다만 head와 tail은 empty list와 매칭시킬 수 없다.
- `|`는 아이템을 리스트의 맨 앞에 추가하는 데에도 사용가능하다.

```elixir
list = [1, 2, 3]
[0 | list] >> [0, 1, 2, 3]
```

- 패턴을 매칭시킬때 굳이 읽고 싶지 않는 경우도 있다. 그 경우 `_`를 사용한다. 그리고 `_`값은 읽을 수 없다.
- `[head | _] = [1, 2, 3]`

### 핀 연산자

- 변수가 리바운드 되는 것을 원치 않을 경우, `^`를 사용하면 된다.
