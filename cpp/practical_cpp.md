## Practical C++

## namesapce로 static 사용하기
* `static`키워드가 있지만, namespace를 사용하는 방법도 있다.
* namespace에 이름을 정의하지 않는다면 static처럼 사용가능하다.
```cpp
namespace {
  int num = 8;
}
```

## 래퍼런스
### 개념
* 어떤 값에 새로운 이름을 또 붙여주는 것이라 생각하면 간단하다.
* 따라서 래퍼런스의 값을 바꾸면 래퍼런스가 바라보는 값도 바뀐다.
* 래퍼런스는 이미 선언된 값을 참조해야한다. 초기화 없이 래퍼런스를 사용할 순 없다.
### 상수 래퍼런스(const)
* 상수로 래퍼런스를 초기화해선 안된다.
* 상수로 초기화를 원할때에는 `const`키워드를 사용하라
```cpp
const int &ref = 4;
```
### 래퍼런스 배열
* 래퍼런스로 배열을 초기화할 수 없다.
* 배열값을 래퍼런스에 할당해야한다.
```cpp
int arr[3] = {1, 2, 3};
int (&ref)[3] = arr;
```
### 래퍼런스를 리턴하는 함수
* 래퍼런스를 리턴하는 함수를 만들 때에는 리턴하는 래퍼런스의 생명주기가 중요하다.
* 함수내의 지역변수와 같은 것은 함수 종료와 동시에 죽는다. 이런 값을 래퍼런스로 리턴해서는 안된다.
* 래퍼런스를 리턴하면 구조체와 같이 크기가 큰 요소들을 주소만 리턴하게 되어서 값을 리턴하는 것보다 아주 빠르게 리턴할 수 있다.
```cpp
//이런 함수는 만들어선 안된다.
int& foo() {
  int a = 3; //a의 생명주기는 foo 종료후 죽는다.
  return a;
}
```
### 값을 래퍼런스로 받기
* 값을 래퍼런스로 받으면 에러가 난다.
* 그러나 상수 래퍼런스로 받게되면 해당 래퍼런스가 죽을 때까지 값의 수명이 늘어나게된다.
```cpp
int function() { } //값을 리턴하는 함수
int &num = function();
```

## 클래스(객체)
### 기본 접근지정자
* class를 만들때 접근지정자를 명시하지 않으면 기본적으로 `private`이 들어간다.
### 생성자
```cpp
class Name {
  public:
    Name() {}
};
```
### 기본생성자
* 자바와 동일하게 생성자를 직접만들면 기본생성자는 생성되지않는다.
* 직접 NoArgsConstructor를 만들어야한다.
* 이는 c++ 11부터 적용된다.
```cpp
public:
  Test() = default;
```
### 정적팩토리메서드
* 정적팩토리메서드는 자바와 동일하다
```cpp
class Name {
  pubilc:
    static 리턴타입 name() {}
};
Name::name();
```
### 소멸자
* 인스턴스 변수중에 힙메모리에 접근하는 변수가 있는 경우에는 소멸자를 지정해야한다.
* 소멸자는 인자를 가지지도, 오버로딩도 하지 않는다.
* 소멸자의 구현부에서 적절하게 힙메모리 접근 인스턴스 변수를 `delete`해주면된다.
```cpp
public:
  ~class이름();
```
### 복사생성자
* 객체를 복사하면 복사하여 다른 메모리에 위치시켜야한다.
* 이에 따라 복사생성자가 동작하는데, 디폴트 복사생성자가 있으나, 기호에 따라 복사생성자를 만들어준다.
* 복사생성자 만들때 주의 할점은 힙메모리에 접근하는 인스턴스가 있는경우 `=`으로 대입시키면안되고, `new` 키워드로 새로 메모리를 생성 후 대입한다.
```cpp
class Name {
public:
  Name(const Name& name);
};

Name(const Name& name() {
  인스턴스변수1 = name.인스턴스변수1;
}
```

## 배열
### 배열생성
* `T* name = new T[size];`
* delete[] name;
