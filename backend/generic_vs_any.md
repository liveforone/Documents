# 제네릭 VS Any -> 더나은 재사용 함수를 만드는 법

## Intro

- 코틀린, 타입스크립트 등의 현대화?된 언어에는 거의 모든 타입을 담을 수 있는 그릇인 Any타입을 지원한다.
- 함수에서 매개변수를 받거나, 함수의 리턴값을 설정할때, 뛰어난 재사용성을 위해 Any를 사용하는 방법과 제네릭을 사용하는 방법중 무엇이 더 나은 선택일지 고민해보자

## 제네릭의 장점

- 결론부터 말하면 제네릭을 사용하는 것이 좋다.
- 이에 대한 예시를 코틀린과 타입스크립트 두 언어로 설명하겠다.

### 1. 타입 안전성

- 제네릭을 사용하면 컴파일 타임에 타입 안전성을 보장할 수 있다.
- 이유는 특정 타입(T)에 제한 되어있기 때문이다.
- 따라서 컴파일러가 타입 불일치로 인한 에러를 잡아낼 수 있다.
- Any를 사용하게 되면 이러한 장점이 없어서 런타임 시에 예기치 않은 타입 오류가 발생할 수 있다.

### 2. 코드 가독성과 유지보수성

- 제네릭을 사용하면 함수 선언부에 타입이 명시적으로 드러난다.
- 이 때문에 함수의 사용의도가 잘 드러난다.
- 그러나 이러한 장점은 코틀린에서만 유효하다.

### 3. 오류 발견 및 디버깅

- 제네릭을 사용하면 ts/kotlin 모두 컴파일러가 타입 불일치를 해결하고, 디버깅을 보다 쉽게 할 수 있게 도와준다.

## 제네릭 예시

### 타입스크립트

```typescript
//any를 사용할 때 : Bad!
export function validateFoundData(foundData: any): void {
  ...
}

//제네릭을 사용할 때 : Good!
export function validateFoundData<T>(foundData: T): void {
  ...
}
```

### 코틀린

```kotlin
fun validateFoundData(foundData: Any) {
  ...
}

fun <T> validateFoundData(foundData: T) {
  ...
}
```

## 번외 : 코틀린에서 Class<T>을 써야하는 경우

- 타입스크립트/자바스크립트에서는 `JSON` 라이브러리를 통해 아주 손쉽게 객체를 직렬화, 역직렬화 할 수 있다.
- 그러나 코틀린은 그렇지 않다.
- 코틀린은 컴파일이 끝나고 런타임시 T를 소거하여 없앤다.
- 이는 자바와의 상호운용을 위해서다.
- 따라서 런타임에는 T에 대한 구체적인 타입정보가 없다.
- 따라서 해당 타입을 참조할때 문제가 발생하게 된다.
- 이때 타입 객체를 생성하거나 참조하길 원한다면 `Class<T>`를 사용해서 런타임에서 제네릭 타입 정보를 보존할 수 있다.
- 따라서 `Class<T>`를 사용해야하는 경우는 다음과 같다.

1. 제네릭 타입 정보를 런타임에서 사용해야하거나, 참조할 때 사용한다.
   - 캐싱을 예로 들 때, save함수를 호출하는 경우가 아닌, read(get) 함수를 호출할 때 사용한다. 왜냐하면 이때 캐싱된 객체를 참조하기 때문이다.
2. 동적으로 객체를 생성할 때 사용한다.
3. 리플랙션을 사용할 때 사용한다.

```kotlin
fun <T> getByKey(
        key: String,
        clazz: Class<T>
    ): T? {
        val result = redisTemplate.opsForValue()[key].toString()
        return if (result.isEmpty()) {
            null
        } else {
            return objectMapper.readValue(result, clazz)
        }
    }
```
